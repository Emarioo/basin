#include "basin/basin.h"

#include "basin/core/driver.h"
#include "basin/logger.h"
#include "basin/error.h"

#include "platform/string.h"
#include "platform/file.h"
#include "platform/thread.h"
#include "platform/assert.h"

static const char BASIN_COMPILER_VERSION[] = "0.0.1-dev";

// defined in this auto-generated file: bin/int/commit_hash.c (generated by build.py)
extern const char* BASIN_COMPILER_COMMIT;
extern const char* BASIN_COMPILER_BUILD_DATE;

const char* basin_version(int version[3]) {
    if(version) {
        const char *start;
        char* end;
        int part;

        start = BASIN_COMPILER_VERSION;
        part = strtol(start, &end, 10);
        version[0] = part;
        
        start = end + 1; // +1 to skip dot
        part = strtol(start, &end, 10);
        version[1] = part;

        start = end + 1;
        part = strtol(start, &end, 10);
        version[2] = part;
    }
    return BASIN_COMPILER_VERSION;
}

const char* basin_commit() {
    return BASIN_COMPILER_COMMIT;
}
const char* basin_build_date() {
    return BASIN_COMPILER_BUILD_DATE;
}

BasinResult basin_compile_file(const char* path, const char* output_path, const BasinCompileOptions* options) {
    BasinResult result = {};
    
    // NOTE: We resolve import paths in a special way but this is the initial source file which
    //  is absolute or relative to current working directory. No resolving here.
    basin_string text = basin_read_whole_file(path, options);
    if(!text.ptr) {
        FORMAT_ERROR(result, BASIN_FILE_NOT_FOUND, "Cannot read '%s'\n", path);
        return result;
    }
    
    result = basin_compile_text(text.ptr, text.len, path, output_path, options);

    basin_allocate(0, text.ptr, options);

    return result;
}

BasinResult basin_compile_text(const char* text, u64 size, const char* path, const char* output_path, const BasinCompileOptions* options) {
    BasinResult result = {};

    Driver* driver = driver_create();
    driver->options = options;

    cstring c_path;
    if (path)
        c_path = cstr_cptr(path);
    else
        c_path = cstr_cptr("<unknown>");

    Task task = {};
    task.kind = TASK_TOKENIZE;
    task.tokenize.import = driver_create_import_id(driver, c_path);
    task.tokenize.import->text = string_clone(text, size);

    driver_add_task(driver, &task);

    driver_run(driver);

    // Driver finished compiling code
    // user metaprograms finished executing
    // Driver finished generating x86 (if that was specified), bytecode is finished at least
    // Driver spat out executable, shared library, bytecode or whatever was specified.
    
    // write it to a file

    return result;
}





void* basin_allocate(int new_size, void* old_ptr, const BasinCompileOptions* options) {
    if(options->allocator.allocate) {
        return options->allocator.allocate(new_size, old_ptr, options->allocator.user_data);
    }

    if (new_size > 0 && old_ptr) {
        return heap_realloc(old_ptr, new_size);
    } else if (new_size > 0) {
        return heap_alloc(new_size);
    } else {
        heap_free(old_ptr);
        return NULL;
    }
}


basin_string basin_read_whole_file(const char* path, const BasinCompileOptions* options) {
    if(options->filesystem.read_whole_file) {
        return options->filesystem.read_whole_file(path, options->filesystem.user_data);
    }
    
    basin_string out = {0};

    u64 size;
    FileHandle handle = open_file(path, &size);
    if(!handle)
        return out;

    char* data = basin_allocate(size, NULL, options);
    if(!data)
        return out;
    
    bool success = read_file(handle, data, size);
    if(!success)
        return out;

    close_file(handle);

    out.ptr = data;
    out.len = size;
    out.allocator = &options->allocator;

    return out;
}

bool basin_write_whole_file(const char* path, char* data, u64 size, const BasinCompileOptions* options) {
    if(options->filesystem.write_whole_file) {
        return options->filesystem.write_whole_file(path, data, size, options->filesystem.user_data);
    }
    
    FileHandle handle = open_file(path, NULL);
    if(!handle)
        return false;

    bool success = write_file(handle, data, size);
    if(!success) {
        close_file(handle);
        return false;
    }

    close_file(handle);

    return true;
}


BasinFS_FileInfo basin_file_info(const char* path, const BasinCompileOptions* options) {
    BasinFS_FileInfo out = {0};
    out.exists = get_file_info(path, &out.is_directory, &out.file_size);
    return out;
}

typedef char* cptr;
DEF_ARRAY(cptr)

BasinResult basin_parse_arguments(const char* arguments, BasinCompileOptions* options) {
    BasinResult result = { 0 };
    result.error_type = BASIN_SUCCESS;
    
    Array_cptr ptr_list;
    
    array_init(&ptr_list, 50);

    int head = 0;
    int len = strlen(arguments);
    bool in_string = 0;
    bool in_word = 0;
    int start_arg = 0;
    while (head<len) {
        char chr = arguments[head];
        head++;

        if (chr == '"') {
            if (in_string) {
                if (!in_word) {
                    int length = head-1 - start_arg;
                    char* arg = (char*)heap_alloc(length + 1);
                    memcpy(arg, arguments + start_arg, length);
                    arg[length] = '\0';
                    array_push(&ptr_list, &arg);
                }
                in_string = false;
                continue;
            } else {
                if (!in_word) {
                    start_arg = head;
                }
                in_string = true;
                continue;
            }
        }

        if (in_string)
            continue;

        if (chr == ' ' || chr == '\n' || chr == '\t' || chr == '\r') {
            if (in_word) {
                int length = head-1 - start_arg;
                char* arg = (char*)heap_alloc(length + 1);
                memcpy(arg, arguments + start_arg, length);
                arg[length] = '\0';
                array_push(&ptr_list, &arg);
                in_word = false;
                continue;
            }
            continue;
        }

        if (!in_word) {
            start_arg = head-1;
            in_word = true;
        }

        if (head == len) {
            int length = head - start_arg;
            char* arg = (char*)heap_alloc(length + 1);
            memcpy(arg, arguments + start_arg, length);
            arg[length] = '\0';
            array_push(&ptr_list, &arg);
            in_word = false;
            continue;
        }
    }
    // @TODO Handle unterminated string
    // @TODO Handle escape characters in string

    result = basin_parse_argv(ptr_list.len, (const char**)ptr_list.ptr, options);

    for (int i=0;i<ptr_list.len;i++) {
        free(ptr_list.ptr[i]);
    }

    array_cleanup(&ptr_list);

    return result;
}

BasinResult basin_parse_argv(int argc, const char** argv, BasinCompileOptions* options) {
    BasinResult result = { 0 };
    result.error_type = BASIN_SUCCESS;

    memset(options, 0, sizeof(*options));

    if (argc == -1) {
        argc++;
        while (argv[argc++]) ;
    }

    int argi = 1;
    while (argi < argc) {
        const char* arg = argv[argi];
        argi++;

        if(!strcmp(arg, "-h") || !strcmp(arg, "--help")) {
            options->print_help = true;
        } else if(!strcmp(arg, "--")) {
            options->start_of_user_args = argi;
            break;
        } else if(!strcmp(arg, "-o")) {
            if (argi >= argc) {
                FORMAT_ERROR(result, BASIN_INVALID_COMPILE_OPTIONS, "ERROR: Missing output path after '%s'\n", arg);
                return result;
            }
            options->output_file = argv[argi];
            argi++;
        } else if(!strncmp(arg, "-O", 2)) {
            options->optimize_flags = BASIN_OPTIMIZE_FLAG_all;
        } else if(!strcmp(arg, "-g")) {
            options->disable_debug = false;
        // } else if(!strncmp(arg, "-I", 2)) {
        //     int len = strlen(arg);
        //     if (len == 2) {
        //         if (argi >= argc) {
        //             fprintf(stderr, "ERROR: Missing output path after '%s'\n", arg);
        //             return 1;
        //         }
        //     }
        //     output_file = argv[argi];
        //     argi++;
        } else if (!strcmp(arg, "-t")) {
            if (argi >= argc) {
                FORMAT_ERROR(result, BASIN_INVALID_COMPILE_OPTIONS, "ERROR: Missing thread count after '%s'\n", arg);
                return result;
            }
            options->threads = atoi(argv[argi]);
            argi++;
        } else if(arg[0] == '-') {
            FORMAT_ERROR(result, BASIN_INVALID_COMPILE_OPTIONS, "ERROR: Unknown argument '%s'. See --help\n", arg);
            return result;
        } else {
            if (options->input_file) {
                FORMAT_ERROR(result, BASIN_INVALID_COMPILE_OPTIONS, "ERROR: Multiple input files are not allowed, '%s'\n", arg);
                return result;
            }
            options->input_file = arg;
        }
    }

    return result;
}


const char* basin_target_arch_string(BasinTargetArch arch) {
    static const char* names[BASIN_TARGET_ARCH_COUNT] = {
        "none",
        "host",
        "x86",
        "x86_64",
        "arm",
        "aarch64",
    };
    if (arch < 0 || arch >= BASIN_TARGET_ARCH_COUNT)
        return NULL;
    return names[arch];
}

const char* basin_target_os_string(BasinTargetOS os) {
    static const char* names[BASIN_TARGET_OS_COUNT] = {
        "none",
        "host",
        "windows",
        "linux",
    };
    if (os < 0 || os >= BASIN_TARGET_OS_COUNT)
        return NULL;
    return names[os];
}