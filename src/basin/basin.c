#include "basin/basin.h"

#include "basin/core/driver.h"
#include "basin/logger.h"

#include "platform/string.h"
#include "platform/file.h"
#include "platform/thread.h"
#include "platform/assert.h"

static const char BASIN_COMPILER_VERSION[] = "0.0.1-dev";

// defined in this auto-generated file: bin/int/commit_hash.c (generated by build.py)
extern const char* BASIN_COMPILER_COMMIT;
extern const char* BASIN_COMPILER_BUILD_DATE;

const char* basin_version(int version[3]) {
    if(version) {
        const char *start;
        char* end;
        int part;

        start = BASIN_COMPILER_VERSION;
        part = strtol(start, &end, 10);
        version[0] = part;
        
        start = end + 1; // +1 to skip dot
        part = strtol(start, &end, 10);
        version[1] = part;

        start = end + 1;
        part = strtol(start, &end, 10);
        version[2] = part;
    }
    return BASIN_COMPILER_VERSION;
}

const char* basin_commit() {
    return BASIN_COMPILER_COMMIT;
}
const char* basin_build_date() {
    return BASIN_COMPILER_BUILD_DATE;
}

BasinResult basin_compile_file(const char* path, const char* output_path, const BasinCompileOptions* options) {
    BasinResult result = {};
    
    // NOTE: We resolve import paths in a special way but this is the initial source file which
    //  is absolute or relative to current working directory. No resolving here.

    basin_string text = basin_read_whole_file(path, options);

    if(!text.ptr) {
        int max = 512;
        result.error_type = BASIN_FILE_NOT_FOUND;
        char* text = basin_allocate(max, NULL, options);
        ASSERT(result.error_message);
        result.error_message = text;
        result.compile_errors_len = snprintf(text, max, "Cannot read '%s'\n", path);
        return result;
    }
    
    result = basin_compile_text(text.ptr, text.len, output_path, options);

    basin_allocate(0, text.ptr, options);

    return result;
}

BasinResult basin_compile_text(const char* text, u64 size, const char* output_path, const BasinCompileOptions* options) {
    BasinResult result = {};

    Driver* driver = driver_create();
    
    string no_path = {0};
    no_path.ptr = "<unknown>";
    no_path.len = strlen(no_path.ptr);

    Task task = {};
    task.kind = TASK_TOKENIZE;
    // task.tokenize.text.ptr = text;
    // task.tokenize.text.len = size;
    task.tokenize.import = driver_create_import_id(driver, no_path);
    task.tokenize.import->text.ptr = (char*)text; // @const_cast
    task.tokenize.import->text.len = size;

    driver_add_task(driver, &task);

    driver_run(driver);

    // Driver finished compiling code
    // user metaprograms finished executing
    // Driver finished generating x86 (if that was specified), bytecode is finished at least
    // Driver spat out executable, shared library, bytecode or whatever was specified.
    
    // write it to a file

    return result;
}





void* basin_allocate(int new_size, void* old_ptr, const BasinCompileOptions* options) {
    if(options->allocator.allocate) {
        return options->allocator.allocate(new_size, old_ptr, options->allocator.user_data);
    }

    if (new_size > 0 && old_ptr) {
        return heap_realloc(old_ptr, new_size);
    } else if (new_size > 0) {
        return heap_alloc(new_size);
    } else {
        heap_free(old_ptr);
        return NULL;
    }
}


basin_string basin_read_whole_file(const char* path, const BasinCompileOptions* options) {
    if(options->filesystem.read_whole_file) {
        return options->filesystem.read_whole_file(path, options->filesystem.user_data);
    }
    
    basin_string out = {0};

    u64 size;
    FileHandle handle = open_file(path, &size);
    if(!handle)
        return out;

    char* data = basin_allocate(size, NULL, options);
    if(!data)
        return out;
    
    bool success = read_file(handle, data, size);
    if(!success)
        return out;

    close_file(handle);

    out.ptr = data;
    out.len = size;
    out.allocator = &options->allocator;

    return out;
}

bool basin_write_whole_file(const char* path, char* data, u64 size, const BasinCompileOptions* options) {
    if(options->filesystem.write_whole_file) {
        return options->filesystem.write_whole_file(path, data, size, options->filesystem.user_data);
    }
    
    FileHandle handle = open_file(path, NULL);
    if(!handle)
        return false;

    bool success = write_file(handle, data, size);
    if(!success) {
        close_file(handle);
        return false;
    }

    close_file(handle);

    return true;
}


BasinFS_FileInfo basin_file_info(const char* path, const BasinCompileOptions* options) {
    BasinFS_FileInfo out = {0};
    out.exists = get_file_info(path, &out.is_directory, &out.file_size);
    return out;
}