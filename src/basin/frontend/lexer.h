#pragma once

#include "basin/types.h"

#include "platform/array.h"

#define DEBUG_BUILD

//#################################
//      ENUMS AND STRUCTS
//#################################

typedef enum {
    // prefixed with T to prevent collisions (CONST collides with windows headers)
    T_END_OF_FILE = 0,
    T_IDENTIFIER,
    T_LITERAL_INTEGER,
    T_LITERAL_FLOAT,
    T_LITERAL_STRING,

    T_STRUCT, 
    KEYWORD_BEGIN = T_STRUCT,
    T_FN,
    T_ENUM,
    T_GLOBAL,
    T_IMPORT,
    T_LIBRARY,
    T_AS,
    T_FROM,
    T_CONST,
    T_VAR,
    T_FOR,
    T_WHILE,
    T_IF,
    T_ELSE,
    T_SWITCH,
    T_CASE,
    T_DEFAULT,
    T_IN,
    T_RETURN,
    T_YIELD,
    T_CONTINUE,
    T_BREAK,
    T_DEFER,
    KEYWORD_END = T_DEFER + 1,
    NORMAL_TOKEN_END = T_DEFER + 1,

    // We can handle keywords from 0 to 32.
    // Then we have hashtag, dollar, parenthessis, dot, plus which are their own tokens.
    // then we have numbers, letters which we can use for a keyword spot.
    
    // Use character literals, not these
    // We define these because they show up during debugging

    // Generated by ChatGPT
    #ifdef DEBUG_BUILD
    T_SPACE        = 32, // ' '
    T_EXCLAMATION  = 33, // '!'
    T_QUOTE        = 34, // '"'
    T_HASH         = 35, // '#'
    T_DOLLAR       = 36, // '$'
    T_PERCENT      = 37, // '%'
    T_AMPERSAND    = 38, // '&'
    T_APOSTROPHE   = 39, // '\''
    T_LPAREN       = 40, // '('
    T_RPAREN       = 41, // ')'
    T_STAR         = 42, // '*'
    T_PLUS         = 43, // '+'
    T_COMMA        = 44, // ','
    T_MINUS        = 45, // '-'
    T_DOT          = 46, // '.'
    T_SLASH        = 47, // '/'

    T_0            = 48, // '0'
    T_1            = 49,
    T_2            = 50,
    T_3            = 51,
    T_4            = 52,
    T_5            = 53,
    T_6            = 54,
    T_7            = 55,
    T_8            = 56,
    T_9            = 57,

    T_COLON        = 58, // ':'
    T_SEMICOLON    = 59, // ';'
    T_LESS         = 60, // '<'
    T_EQUAL        = 61, // '='
    T_GREATER      = 62, // '>'
    T_QUESTION     = 63, // '?'
    T_AT           = 64, // '@'

    T_A            = 65, // 'A'
    T_B            = 66,
    T_C            = 67,
    T_D            = 68,
    T_E            = 69,
    T_F            = 70,
    T_G            = 71,
    T_H            = 72,
    T_I            = 73,
    T_J            = 74,
    T_K            = 75,
    T_L            = 76,
    T_M            = 77,
    T_N            = 78,
    T_O            = 79,
    T_P            = 80,
    T_Q            = 81,
    T_R            = 82,
    T_S            = 83,
    T_T            = 84,
    T_U            = 85,
    T_V            = 86,
    T_W            = 87,
    T_X            = 88,
    T_Y            = 89,
    T_Z            = 90,

    T_LBRACKET     = 91, // '['
    T_BACKSLASH    = 92, // '\'
    T_RBRACKET     = 93, // ']'
    T_CARET        = 94, // '^'
    T_UNDERSCORE   = 95, // '_'
    T_BACKTICK     = 96, // '`'

    T_a            = 97, // 'a'
    T_b            = 98,
    T_c            = 99,
    T_d            = 100,
    T_e            = 101,
    T_f            = 102,
    T_g            = 103,
    T_h            = 104,
    T_i            = 105,
    T_j            = 106,
    T_k            = 107,
    T_l            = 108,
    T_m            = 109,
    T_n            = 110,
    T_o            = 111,
    T_p            = 112,
    T_q            = 113,
    T_r            = 114,
    T_s            = 115,
    T_t            = 116,
    T_u            = 117,
    T_v            = 118,
    T_w            = 119,
    T_x            = 120,
    T_y            = 121,
    T_z            = 122,

    T_LBRACE       = 123, // '{'
    T_PIPE         = 124, // '|'
    T_RBRACE       = 125, // '}'
    T_TILDE        = 126, // '~'
    #endif
} _TokenKind;

typedef u8 TokenKind;

typedef enum {
    TF_PRE_SPACE    = 0x1,
    TF_POST_SPACE   = 0x2,
    TF_PRE_NEWLINE  = 0x4,
    TF_POST_NEWLINE = 0x8,
} _TokenFlags;

typedef u8 TokenFlags;

extern char* token_name_table[NORMAL_TOKEN_END];

typedef struct {
    #ifdef DEBUG_BUILD
        _TokenKind kind;
        _TokenFlags flags;
    #else
        TokenKind  kind;
        TokenFlags flags;
    #endif
    ImportID   import_id; // do we need import id since we don't have preprocessor?
    int        position;
} Token;

typedef struct {
    #ifdef DEBUG_BUILD
        _TokenKind kind;
        _TokenFlags flags;
    #else
        TokenKind  kind;
        TokenFlags flags;
    #endif
    ImportID   import_id;
    int        position;

    union {
        char* ptr_data;
        int  int_data;
    };
} TokenExt;

typedef struct {
    u16       _reserved;
    ImportID  import_id;
    int       position;
} SourceLocation;

// #define IS_EXT_TOKEN(K) ((K >= T_IDENTIFIER && K <= T_LITERAL_STRING) || K == '{' || K == '}' || K == '(' || K == ')' )
#define IS_EXT_TOKEN(K) (K >= T_IDENTIFIER && K <= T_LITERAL_STRING)
#define IS_EOF(TOK) ((TOK) == &EOF_TOKEN_EXT)

#define IS_KEYWORD(K) (K >= KEYWORD_BEGIN && K < KEYWORD_END)

#define IS_SPECIAL(K) (K >= KEYWORD_END)

#define HAS_PRE_WHITESPACE(TOK) ((TOK)->flags & (TF_PRE_NEWLINE | TF_PRE_SPACE))


#define DATA_FROM_TOKEN(T) { (T)->ptr_data+1, *((u8*)(T)->ptr_data) }
#define DATA_FROM_STRING(T) { ( ASSERT((T)->kind == T_LITERAL_STRING), (T)->ptr_data+2), *((u16*)(T)->ptr_data) }
#define DATA_FROM_IDENTIFIER(T) { (ASSERT((T)->kind == T_IDENTIFIER), (T)->ptr_data+1), *((u8*)(T)->ptr_data) }

#define TOKEN_PER_EXT_TOKEN ((sizeof(TokenExt)+sizeof(Token)-1)/sizeof(Token))

typedef struct TokenStream {
    const Import* import;

    Token* tokens;
    int tokens_len, tokens_max;

    char* data;
    int data_len, data_max;

    Array_int line_positions;
} TokenStream;

// static const Token EOF_TOKEN = { T_END_OF_FILE, 0, -1, -1 };
static const TokenExt EOF_TOKEN_EXT = { T_END_OF_FILE, 0, -1, -1, NULL };

//###############################
//       PUBLIC FUNCTIONS
//###############################

Result tokenize(const Import* import, TokenStream** out_stream);

// This is an expensive operation, we calculate line numbers
void print_lines_from_token_stream(TokenStream* stream, Token token);

const char* name_from_token(TokenKind token);

SourceLocation location_from_token(const TokenExt* tok);

bool compute_source_info(TokenStream* stream, SourceLocation location, int* line, int* column, string* code);

void print_token_stream(TokenStream* stream);

void token_stream_cleanup(TokenStream* stream);
