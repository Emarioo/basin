/*
    This file contains Unix specific features.
    - Wrapper for syscalls
    - No libc
    
    Note that this module is just for convenience.
    The headers for Linux are complex with many #ifdefs (struct_stat.h for example)
    so this file assumes x86_64 and other things. It should be fine on a modern 64-bit x86 Linux machine.

    Most macros are copied from /usr/include/x86_64-linux-gnu/bits/...

    TODO: getaddrinfo is not a syscall and exists in libc so we must link with it if the user uses it.
*/


const STDIN_FILENO  = 0
const STDOUT_FILENO = 1
const STDERR_FILENO = 2

/* open/fcntl.  */
const O_RDONLY    = 0o0
const O_WRONLY    = 0o1
const O_RDWR      = 0o2
const O_CREAT     = 0o100 /* Not fcntl.  */
const O_EXCL      = 0o200 /* Not fcntl.  */
const O_NOCTTY    = 0o400 /* Not fcntl.  */
const O_TRUNC     = 0o1000 /* Not fcntl.  */
const O_APPEND    = 0o2000
const O_NONBLOCK  = 0o4000
const O_SYNC      = 0o4010000
const O_ASYNC     = 0o20000
const O_LARGEFILE = 0o100000
const O_DIRECTORY = 0o200000
const O_NOFOLLOW  = 0o400000
const O_CLOEXEC   = 0o2000000
const O_DIRECT    = 0o40000
const O_NOATIME   = 0o1000000
const O_PATH      = 0o10000000
const O_DSYNC     = 0o10000
const O_TMPFILE   = (0o20000000 | O_DIRECTORY)

const SEEK_SET    = 0 // seeks from start
const SEEK_CUR    = 1 // seeks from current
const SEEK_END    = 2 // seels from end

const PROT_READ   = 0x1  /* Page can be read.  */
const PROT_WRITE  = 0x2  /* Page can be written.  */
const PROT_EXEC   = 0x4  /* Page can be executed.  */
const PROT_NONE   = 0x0  /* Page can not be accessed.  */

/* Sharing types (must choose one and only one of these).  */
const MAP_SHARED          = 0x01  /* Share changes.  */
const MAP_PRIVATE         = 0x02  /* Changes are private.  */
const MAP_SHARED_VALIDATE = 0x03 /* Share changes and validate extension flags.  */
const MAP_TYPE            = 0x0f  /* Mask for type of mapping.  */

/* Other flags.  */
const MAP_FIXED       = 0x10  /* Interpret addr exactly.  */
const MAP_ANONYMOUS   = 0x20  /* Don't use a file.  */
const MAP_32BIT       = 0x40  /* Only give out 32-bit addresses.  */

const MAP_GROWSDOWN   = 0x00100  /* Stack-like segment.  */
const MAP_DENYWRITE   = 0x00800  /* ETXTBSY.  */
const MAP_EXECUTABLE  = 0x01000  /* Mark it as an executable.  */
const MAP_LOCKED      = 0x02000  /* Lock the mapping.  */
const MAP_NORESERVE   = 0x04000  /* Don't check for reservations.  */
const MAP_POPULATE    = 0x08000  /* Populate (prefault) pagetables.  */
const MAP_NONBLOCK    = 0x10000  /* Do not block on IO.  */
const MAP_STACK       = 0x20000  /* Allocation is for a stack.  */
const MAP_HUGETLB     = 0x40000  /* Create huge page mapping.  */
const MAP_SYNC        = 0x80000  /* Perform synchronous page
        faults for the mapping.  */
const MAP_FIXED_NOREPLACE = 0x100000 /* MAP_FIXED but do not unmap
        underlying mapping.  */

const GRND_NONBLOCK   = 0x01
const GRND_RANDOM     = 0x02

const DT_UNKNOWN  = 0
const DT_FIFO     = 1
const DT_CHR      = 2
const DT_DIR      = 4
const DT_BLK      = 6
const DT_REG      = 8
const DT_LNK      = 10
const DT_SOCK     = 12
const DT_WHT      = 14

const S_IFMT      = 0o170000 // bit mask for the file type bit field
const S_IFSOCK    = 0o140000 // socket
const S_IFLNK     = 0o120000 // symbolic link
const S_IFREG     = 0o100000 // regular file
const S_IFBLK     = 0o060000 // block device
const S_IFDIR     = 0o040000 // directory
const S_IFCHR     = 0o020000 // character device
const S_IFIFO     = 0o010000 // FIFO

const S_ISUID = 0o4000 /* Set user ID on execution.  */
const S_ISGID = 0o2000 /* Set group ID on execution.  */
const S_ISVTX = 0o1000 /* Save swapped text after use (sticky).  */
const S_IRUSR = 0o400 /* Read by owner.  */
const S_IWUSR = 0o200 /* Write by owner.  */
const S_IXUSR = 0o100 /* Execute by owner.  */


const P_ALL   = 0 /* Wait for any child.  */
const P_PID   = 1 /* Wait for specified process.  */
const P_PGID  = 2 /* Wait for members of process group.  */


/* Bits in the third argument to `waitpid'.  */
const	WNOHANG		= 1	/* Don't block waiting.  */
const	WUNTRACED	= 2	/* Report status of stopped children.  */

/* Bits in the fourth argument to `waitid'.  */
const WSTOPPED	= 2	/* Report stopped child (same as WUNTRACED). */
const WEXITED	= 4	/* Report dead child.  */
const WCONTINUED	= 8	/* Report continued child.  */
const WNOWAIT	= 0x01000000 /* Don't reap, just poll status.  */

/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
// const	WEXITSTATUS(status)	(((status) & 0xff00) >> 8)

/* If WIFSIGNALED(STATUS), the terminating signal.  */
// const	WTERMSIG(status)	((status) & 0x7f)

/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
// const	WSTOPSIG(status)	WEXITSTATUS(status)

/* Nonzero if STATUS indicates normal termination.  */
// const	WIFEXITED(status)	(WTERMSIG(status) == 0)

/* Nonzero if STATUS indicates termination by a signal.  */
// const WIFSIGNALED(status) ((cast<char> (((status) & 0x7f) + 1) >> 1) > 0)

/* Nonzero if STATUS indicates the child is stopped.  */
// const	WIFSTOPPED(status)	(((status) & 0xff) == 0x7f)

/* Nonzero if STATUS indicates the child continued after a stop.  We only
   macro this if <bits/waitflags.h> provides the WCONTINUED flag bit.  */
// const WIFCONTINUED(status)	((status) == __W_CONTINUED)

/* Nonzero if STATUS indicates the child dumped core.  */
// const	WCOREDUMP(status)	((status) & __WCOREFLAG)

/* Macros for constructing status values.  */
// const	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
// const	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
// const __W_CONTINUED		0xffff
// const	__WCOREFLAG		0x80

const SIGCHLD		= 17	/* Child terminated or stopped.  */

const CLD_EXITED = 1               /* Child has exited.  */
const  CLD_KILLED = 2                   /* Child was killed.  */
const  CLD_DUMPED = 3                   /* Child terminated abnormally.  */
const  CLD_TRAPPED = 4                  /* Traced child has trapped.  */
const  CLD_STOPPED = 5                  /* Child has stopped.  */
const  CLD_CONTINUED = 6                 /* Stopped child has continued.  */

const	R_OK	= 4		/* Test for read permission.  */
const	W_OK	= 2		/* Test for write permission.  */
const	X_OK	= 1		/* Test for execute permission.  */
const	F_OK	= 0		/* Test for existence.  */

const SOCK_STREAM    = 1
const SOCK_DGRAM     = 2
const SOCK_RAW       = 3
const SOCK_RDM       = 4
const SOCK_SEQPACKET = 5
const SOCK_DCCP      = 6
const SOCK_PACKET    = 10  

const SOCK_NONBLOCK  = O_NONBLOCK

// include/linux/socket.h
const AF_INET		= 2	/* Internet IP Protocol 	*/
// const AF_INET6
// TODO: Add more AF_

const SOL_SOCKET = 1
const SO_REUSEADDR = 2

const SHUT_RD = 0
const SHUT_WR = 1
const SHUT_RDWR = 2

const INADDR_ANY = 0


const clockid_t = i32
/* Identifier for system-wide realtime clock.  */
const CLOCK_REALTIME                = 0
/* Monotonic system-wide clock.  */
const CLOCK_MONOTONIC               = 1
/* High-resolution timer from the CPU.  */
const CLOCK_PROCESS_CPUTIME_ID      = 2
/* Thread-specific CPU-time clock.  */
const CLOCK_THREAD_CPUTIME_ID       = 3
/* Monotonic system-wide clock, not adjusted for frequency scaling.  */
const CLOCK_MONOTONIC_RAW           = 4
/* Identifier for system-wide realtime clock, updated only on ticks.  */
const CLOCK_REALTIME_COARSE         = 5
/* Monotonic system-wide clock, updated only on ticks.  */
const CLOCK_MONOTONIC_COARSE        = 6
/* Monotonic system-wide clock that includes time spent in suspension.  */
const CLOCK_BOOTTIME                = 7
/* Like CLOCK_REALTIME but also wakes suspended system.  */
const CLOCK_REALTIME_ALARM          = 8
/* Like CLOCK_BOOTTIME but also wakes suspended system.  */
const CLOCK_BOOTTIME_ALARM          = 9
/* Like CLOCK_REALTIME but in International Atomic Time.  */
const CLOCK_TAI                     = 11



// /usr/include/x86_64-linux-gnu/asm/signal.h:
// /usr/include/asm-generic/signal-defs.h:
const SIGHUP        =   1 /* Hangup.  */
const SIGINT        =   2 /* Interactive attention signal.  */
const SIGQUIT       =   3 /* Quit.  */
const SIGILL        =   4 /* Illegal instruction.  */
const SIGTRAP       =   5 /* Trace/breakpoint trap.  */
const SIGABRT       =   6 /* Abnormal termination.  */
const SIGIOT        =   6
const SIGBUS        =   7 /* Bus error.  */
const SIGFPE        =   8 /* Erroneous arithmetic operation.  */
const SIGKILL       =   9 /* Killed.  */
const SIGUSR1       =  10 /* User-defined signal 1.  */
const SIGSEGV       =  11 /* Invalid access to storage.  */
const SIGUSR2       =  12 /* User-defined signal 2.  */
const SIGPIPE       =  13 /* Broken pipe.  */
const SIGALRM       =  14 /* Alarm clock.  */
const SIGTERM       =  15 /* Termination request.  */
const SIGSTKFLT     =  16
const SIGCHLD       =  17
const SIGCONT       =  18
const SIGSTOP       =  19
const SIGTSTP       =  20
const SIGTTIN       =  21
const SIGTTOU       =  22
const SIGURG        =  23
const SIGXCPU       =  24
const SIGXFSZ       =  25
const SIGVTALRM     =  26
const SIGPROF       =  27
const SIGWINCH      =  28
const SIGIO         =  29
const SIGPOLL       =  SIGIO
/*
#define SIGLOST         29
*/
const SIGPWR         = 30
const SIGSYS         = 31
const SIGUNUSED      = 31

/* Bits in `sa_flags'.  */
const SA_NOCLDSTOP = 1		 /* Don't send SIGCHLD when children stop.  */
const SA_NOCLDWAIT = 2		 /* Don't create zombie on child death.  */
const SA_SIGINFO   = 4		 /* Invoke signal-catching function with
				    three arguments instead of one.  */
// #if defined __USE_XOPEN_EXTENDED || defined __USE_MISC
const SA_ONSTACK  = 0x08000000 /* Use signal stack by using `sa_restorer'. */
// #endif
// #if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
const SA_RESTART   = 0x10000000 /* Restart syscall on signal return.  */
const SA_NODEFER   = 0x40000000 /* Don't automatically block the signal when
				    its handler is being executed.  */
const SA_RESETHAND = 0x80000000 /* Reset to SIG_DFL on entry to handler.  */
// #endif
// #ifdef __USE_MISC
const SA_INTERRUPT  =  0x20000000 /* Historical no-op.  */
const SA_RESTORER   =  0x04000000

/* Values for the HOW argument to `sigprocmask'.  */
const	SIG_BLOCK    = 0		 /* Block signals.  */
const	SIG_UNBLOCK  = 1		 /* Unblock signals.  */
const	SIG_SETMASK  = 2		 /* Set the set of blocked signals.  */

enum Syscall_x86 {
    read                  = 0
    write                 = 1
    open                  = 2
    close                 = 3
    stat                  = 4
    fstat                 = 5
    lstat                 = 6
    poll                  = 7
    lseek                 = 8
    mmap                  = 9
    mprotect              = 10
    munmap                = 11
    rt_sigaction          = 13
    rt_sigprocmask        = 14
    rt_sigreturn          = 15
    access                = 21
    pipe                  = 22
    dup                   = 32
    dup2                  = 33
    nanosleep             = 35
    sendfile              = 40
    socket                = 41
    connect               = 42
    accept                = 43
    sendto                = 44
    recvfrom              = 45
    sendmsg               = 46
    recvmsg               = 47
    shutdown              = 48
    bind                  = 49
    listen                = 50
    getsockname           = 51
    setsockopt            = 54
    getsockopt            = 55
    fork                  = 57
    vfork                 = 58
    execve                = 59
    exit                  = 60
    kill                  = 62
    getdents              = 78
    getcwd                = 79
    rename                = 82
    mkdir                 = 83
    rmdir                 = 84
    unlink                = 87
    getdents64            = 217
    clock_getres          = 227
    clock_gettime         = 228
    clock_settime         = 229
    waitid                = 247
    openat                = 257
    getrandom             = 318
}

enum Syscall_arm {
    openat                = 56
}

import "compiler" as basin

fn syscall(ast: AST*, content: string, node: ASTExpression_Block*) {
    for 0..node.functions.len {
        syscall(ast, content, node.functions.ptr[nr])
    }
}

fn syscall(ast: AST*, content: string, node: ASTFunction*) {

    // What we expect to generate
    //   switch compiler.platform() {
    //       case x86_64
    //           return asm(arg0, arg1, arg2, arg3) -> sword {
    //               mov r10, rcx
    //               mov eax, {Syscall_x86_64.sendfile}
    //               syscall
    //           }
    //       case arm_64
    //           return asm(arg0, arg1, arg2, arg3) -> sword {
    //               ldr x8, {Syscall_arm.sendfile}
    //               svc #0
    //           }
    //   }
    ASSERT(node.body!) // syscall annotation only allowed on functions with 

    text : string = f"{\n"
    text.append("switch compiler.platform() {\n")
    text.append("case x86_64\nreturn asm(")
    for 0..func.parameters.len {
        if nr != 0
            text.append(", ")
        text.append("arg", nr)
    }
    text.append(") -> sword {\n")

    fn find_syscall_number(name: string, enum_name: string, ast: AST* = ast) -> i32 {
        global cached_enum: ASTEnum*

        if cached_enum! {
            // Slight optimization, cache the enum so we don't search for
            // it for each syscall.
            // Assumes enum exists and @syscall appeared in linux.bsn and nowhere
            // else.
            cached_enum = basin.find_enum(ast, enum_name)
        }

        mem: ASTEnum_Member* = basin.find_enum_member(cached_enum, name)

        expr := mem.default_value : ASTExpression_Literal
        return expr.int_value
    }

    if func.parameters.len > 3 {
        text.append("mov r10, rcx\n")
    }
    syscall_num_x86_64 := find_syscall_number(func.name, "Syscall_x86_64")
    text.append("mov eax, ", syscall_num_x86_64, "\n")
    text.append("syscall\n")

    text.append("}\n") // asm
    text.append("case arm_64\nreturn asm(")
    for 0..func.parameters.len {
        text.append("arg", nr,", ")
    }
    text.append("sys) -> sword {\n")
    
    syscall_num_arm_64 := find_syscall_number(func.name, "Syscall_arm")
    text.append("ldr x8, #", syscall_num_arm_64, "\n")

    text.append("}\n") // asm

    text.append("}\n") // switch

    text.append("}\n") // expr block
    
    import "string"

    // lex and parse expression using an existing AST's memory allocator.
    // also provide a "metaprogramming" file name
    // or we provide __FILE__, __LINE__
    // which point as parse_expression function call.
    // perhaps that is default arguments for parse_expression?
    src_path : string = join(f"<syscall_{func.name}>")
    expr := basin.parse_expression(text, ast, path = __FILE__, additive_line = __LINE__)
    func.body = expr
}

@syscall fn read(fd: i32, buf: void*, count: u32) -> i32

SYSCALL(read,  i32,  fd: i32, buf: void*, count: u32)
SYSCALL(write, uword,  fd: i32, buf: void*, count: uword)
SYSCALL(open,  i32,  path: char*, flags: i32, mode: i32 = 0)
SYSCALL(close, i32,  fd: i32)
SYSCALL(stat,  i32,  pathname: char*, statbuf: stat*)
SYSCALL(fstat, i32,  fd: i32, statbuf: stat*);
SYSCALL(lstat, i32,  pathname: char*, statbuf: stat*)
SYSCALL(lseek, i32,  fd: i32, offset: i32, whence: i32)
SYSCALL(mmap,  void*, addr: void*, length: i32, prot: i32, flags: i32, fd: i32, offset: i32)
SYSCALL(mprotect,  i32, addr: void*, len: i32, prot: i32);
SYSCALL(munmap,    i32, addr: void*, length: i32)

SYSCALL(rt_sigaction, i32, signum: i32, act: sigaction_t*, old_act: sigaction_t*, sigsetsize: i64)
SYSCALL(rt_sigprocmask, i32, how: i32, set: sigset_t*, oset: sigset_t*, sigsetsize: i64)
SYSCALL_VOID(rt_sigreturn)

// flags to dlopen
const RTLD_LAZY          = 0x00001
const RTLD_NOW           = 0x00002
const RTLD_BINDING_MASK  = 0x3
const RTLD_NOLOAD        = 0x00004
const RTLD_DEEPBIND      = 0x00008
const RTLD_GLOBAL        = 0x00100
const RTLD_LOCAL         = 0
const RTLD_NODELETE      = 0x01000

SYSCALL(access,  i32, path: char*, mode: i32)
SYSCALL(pipe,  i32, fildes: i32*)

SYSCALL(dup, i32, fildes: i32)
SYSCALL(dup2, i32, oldfd: i32, newfd: i32)

SYSCALL(nanosleep, i32, rqtp: timespec*, rmtp: timespec*)

SYSCALL(sendfile, i64, out_fd: i32, in_fd: i32, offset: i64*, count: i64)

SYSCALL(socket, i32, domain: i32, type: i32, protocol: i32)
SYSCALL(connect, i32, sockfd: i32, addr: sockaddr*, addrlen: i32)
SYSCALL(accept, i32, sockfd: i32, addr: sockaddr*, addrlen: i32*)
// SYSCALL(sendto, i32, sockfd: i32, buf: void*, len: i32, flags: i32, dest_addr: sockaddr*, addrlen: i32)
// SYSCALL(recvfrom, i32, )
// SYSCALL(sendmsg, i32, )
// SYSCALL(recvmsg, i32, )
SYSCALL(shutdown, i32, sockfd: i32, how: i32)
SYSCALL(bind, i32, sockfd: i32, addr: sockaddr*, addrlen: i32)
#macro SOMAXCONN 4096
SYSCALL(listen, i32, sockfd: i32, backlog: i32)
SYSCALL(getsockname, i32, sockfd: i32, addr: sockaddr*, addrlen: i32*)

SYSCALL(setsockopt, i32, sockfd: i32, level: i32, optname: i32, optval: char*, optlen: i32)
SYSCALL(getsockopt, i32, sockfd: i32, level: i32, optname: i32, optval: char*, optlen: i32)

SYSCALL(fork,   i32)
SYSCALL(vfork,  i32)
// environment variables can be be acquired from the envp argument in main(argc: i32, argv: char**, envp: char**)
SYSCALL(execve, i32, pathname: char*, argv: char**, envp: char**)
SYSCALL_VOID(exit, status: i32)

SYSCALL(kill, i32, pid: i32, sig: i32)

SYSCALL(getcwd, char*, buf: char*, size: i32)

SYSCALL(rename, i32, oldpath: char*, newpath: char*)
SYSCALL(mkdir, i32, pathname: char*, mode: i32)
SYSCALL(rmdir, i32, pathname: char*)

// SYSCALL(getdents, i32, fd: i32, dirp: linux_dirent*, count: u32);
SYSCALL(getdents64, i32, fd: i32, dirp: void*, count: u32);

SYSCALL(clock_getres,  i32, clockid: clockid_t, res: timespec*);
SYSCALL(clock_gettime, i32, clockid: clockid_t, tp: timespec*);
SYSCALL(clock_settime, i32, clockid: clockid_t, tp: timespec*);

SYSCALL(waitid, i32, type: i32, id: i32, info: siginfo_t*, options: i64, ru: void* = null);

SYSCALL(getrandom, i32, buf: void*, buflen: u32, flags: u32);

// NOTE: These are also defined in Windows.btb
// htonq, ntohq (64-bit swap?)
fn htonl(hostlong: u32) -> u32 {
    // TODO: We assume the program is compiled for x86 (little endian)
    //   If we support ARM, we need to change this.
    return asm<u32>(hostlong) {
        pop rax
        bswap eax
        push rax
    }
    // return (hostlong << 24) | ((hostlong << 8) & 0xFF0000) | (hostlong >> 24) | ((hostlong >> 8) & 0xFF00) 
}
fn htons(hostshort: u16) -> u16 {
    return asm<u32>(hostshort) {
        pop rax
        xchg al, ah
        push rax
    }
    // return (hostshort << 8) | (hostshort >> 8)
}
fn ntohl(netlong: u32) -> u32 {
    return htonl(netlong)
    // return (netlong << 24) | ((netlong << 8) & 0xFF0000) | (netlong >> 24) | ((netlong >> 8) & 0xFF00) 
}
fn ntohs(netshort: u16) -> u16 {
    return htons(netlong)
    // return (netshort << 8) | (netshort >> 8)
}


// I could not find the correct stat structure anywhere but
// this structure seems to be correct.
struct stat {
    // st_dev:         u64;  /* Device.  */
    // st_ino:         u64;  /* File serial number. */ 
    // st_nlink:       u32;  /* Link count.  */
    // _pad23:         u32;
    
    // st_mode:        u32;  /* File mode.  */
    // st_uid:         u32;  /* User ID of the file's owner. */
    // st_gid:         u32;  /* Group ID of the file's group.*/
    
    // st_rdev:        u64;  /* Device number, if device.  */

    // st_size:        i64;  /* Size of file, in bytes.  */
    // st_blksize:     u64;  /* Optimal block size for I/O.  */
    // st_blocks:      u64;  /* Number 512-byte blocks allocated. */

    // st_atime:       u64;  /* Time of last access.  */
    // st_atime_nsec:  u64;  /* Time of last access.  */
    // st_mtime:       u64;  /* Time of last modification.  */
    // st_mtime_nsec:  u64;  /* Time of last modification.  */
    // st_ctime:       u64;  /* Time of last status change.  */
    // st_ctime_nsec:  u64;  /* Time of last status change.  */
    
    st_dev:         u64;  /* Device.  */
    st_ino:         u64;  /* File serial number. */ 
    st_nlink:       u64;  /* Link count.  */
    // _pad23:         u32;
    
    st_mode:        u32;  /* File mode.  */
    st_uid:         u32;  /* User ID of the file's owner. */
    st_gid:         u32;  /* Group ID of the file's group.*/
    _pad0:          u32;  /* Group ID of the file's group.*/
    
    st_rdev:        u64;  /* Device number, if device.  */
    st_size:        i64;  /* Size of file, in bytes.  */
    st_blksize:     i64;  /* Optimal block size for I/O.  */
    st_blocks:      i64;  /* Number 512-byte blocks allocated. */

    st_atime:       u64;  /* Time of last access.  */
    st_atime_nsec:  u64;  /* Time of last access.  */
    st_mtime:       u64;  /* Time of last modification.  */
    st_mtime_nsec:  u64;  /* Time of last modification.  */
    st_ctime:       u64;  /* Time of last status change.  */
    st_ctime_nsec:  u64;  /* Time of last status change.  */
    
    __unused0:      i64;
    __unused1:      i64;
    __unused2:      i64;
};

const ino64_t = u64
const off64_t = i64
const ino_t   = u32
const off_t   = i32

struct linux_dirent {
    d_ino: ino_t;    /* 64-bit inode number */
    d_off: off_t;    /* Not an offset; see getdents() */
    d_reclen: u16; /* Size of this dirent */

    d_name: char[1]; /* Filename (null-terminated) */

    // access through *(cast<u8*>ptr + d_reclen - 1)
    // d_type: u8;   /* File type */
};

struct linux_dirent64 {
    d_ino: ino64_t;    /* 64-bit inode number */
    d_off: off64_t;    /* Not an offset; see getdents() */
    d_reclen: u16; /* Size of this dirent */
    d_type: u8;   /* File type */

    d_name: char[1]; /* Filename (null-terminated) */
};

struct timespec {
    tv_sec: i64;
    tv_nsec: i64;
}



// This struct may be incorrect, I could not find a struct that matched
// the values that waitid returned but this order and integer sizes seem to work.
struct siginfo_t {
    si_signo: i32;
    si_errno: i32;
    si_code : i32;
    uid: i32;
    pid: i32;
    status: i64;
}
// struct sigset_t {
//     n: i32[16]; // (1024 / (8 * sizeof (unsigned long int)))
// }
struct  sigset_t {
    x: i64;
}
#macro FN_SIGACTION fn @oscall(i32, siginfo_t*, void*)
#macro FN_HANDLER fn@oscall(i32)
struct sigaction_t {
    // union { // TODO: Implement unions
    sa_sigaction: FN_SIGACTION;
    // sa_handler: FN_HANDLER;
    // }
    sa_mask: sigset_t;
    sa_flags: i32;
    sa_restorer: fn @oscall();
}

// from netinet/in.h
#macro IPPROTO_TCP 6
#macro IPPROTO_UDP 17

// base sockaddr
struct sockaddr {
    sa_family: i16;
    padding: u8[14];
}
// cast to sockaddr in function calls
struct sockaddr_in {
    sin_family: u16;
    sin_port: u16;
    sin_addr: u32;
    padding: u8[8]; // sockaddr_in should be padded to 16 bytes
}
struct addrinfo {
    ai_flags: i32;
    ai_family: i32;
    ai_socktype: i32;
    ai_protocol: i32;
    ai_addrlen: i64;
    ai_addr: sockaddr*;
    ai_canonname: char*;
    ai_next: addrinfo*;
}


#macro EPERM    1 /* Operation not permitted */
#macro ENOENT   2 /* No such file or directory */
#macro ESRCH    3 /* No such process */
#macro EINTR    4 /* Interrupted system call */
#macro EIO      5 /* I/O error */
#macro ENXIO    6 /* No such device or address */
#macro E2BIG    7 /* Argument list too long */
#macro ENOEXEC  8 /* Exec format error */
#macro EBADF    9 /* Bad file number */
#macro ECHILD   10 /* No child processes */
#macro EAGAIN   11 /* Try again */
#macro ENOMEM   12 /* Out of memory */
#macro EACCES   13 /* Permission denied */
#macro EFAULT   14 /* Bad address */
#macro ENOTBLK  15 /* Block device required */
#macro EBUSY    16 /* Device or resource busy */
#macro EEXIST   17 /* File exists */
#macro EXDEV    18 /* Cross-device link */
#macro ENODEV   19 /* No such device */
#macro ENOTDIR  20 /* Not a directory */
#macro EISDIR   21 /* Is a directory */
#macro EINVAL   22 /* Invalid argument */
#macro ENFILE   23 /* File table overflow */
#macro EMFILE   24 /* Too many open files */
#macro ENOTTY   25 /* Not a typewriter */
#macro ETXTBSY  26 /* Text file busy */
#macro EFBIG    27 /* File too large */
#macro ENOSPC   28 /* No space left on device */
#macro ESPIPE   29 /* Illegal seek */
#macro EROFS    30 /* Read-only file system */
#macro EMLINK   31 /* Too many links */
#macro EPIPE    32 /* Broken pipe */
#macro EDOM     33 /* Math argument out of domain of func */
#macro ERANGE   34 /* Math result not representable */

#macro ENOSYS          38      /* Invalid system call number */

#macro ENOTEMPTY       39      /* Directory not empty */
#macro ELOOP           40      /* Too many symbolic links encountered */
#macro EWOULDBLOCK     EAGAIN  /* Operation would block */
#macro ENOMSG          42      /* No message of desired type */
#macro EIDRM           43      /* Identifier removed */
#macro ECHRNG          44      /* Channel number out of range */
#macro EL2NSYNC        45      /* Level 2 not synchronized */
#macro EL3HLT          46      /* Level 3 halted */
#macro EL3RST          47      /* Level 3 reset */
#macro ELNRNG          48      /* Link number out of range */
#macro EUNATCH         49      /* Protocol driver not attached */
#macro ENOCSI          50      /* No CSI structure available */
#macro EL2HLT          51      /* Level 2 halted */
#macro EBADE           52      /* Invalid exchange */
#macro EBADR           53      /* Invalid request descriptor */
#macro EXFULL          54      /* Exchange full */
#macro ENOANO          55      /* No anode */
#macro EBADRQC         56      /* Invalid request code */
#macro EBADSLT         57      /* Invalid slot */

// #macro EDEADLOCK       EDEADLK

#macro EBFONT          59      /* Bad font file format */
#macro ENOSTR          60      /* Device not a stream */
#macro ENODATA         61      /* No data available */
#macro ETIME           62      /* Timer expired */
#macro ENOSR           63      /* Out of streams resources */
#macro ENONET          64      /* Machine is not on the network */
#macro ENOPKG          65      /* Package not installed */
#macro EREMOTE         66      /* Object is remote */
#macro ENOLINK         67      /* Link has been severed */
#macro EADV            68      /* Advertise error */
#macro ESRMNT          69      /* Srmount error */
#macro ECOMM           70      /* Communication error on send */
#macro EPROTO          71      /* Protocol error */
#macro EMULTIHOP       72      /* Multihop attempted */
#macro EDOTDOT         73      /* RFS specific error */
#macro EBADMSG         74      /* Not a data message */
#macro EOVERFLOW       75      /* Value too large for macrod data type */
#macro ENOTUNIQ        76      /* Name not unique on network */
#macro EBADFD          77      /* File descriptor in bad state */
#macro EREMCHG         78      /* Remote address changed */
#macro ELIBACC         79      /* Can not access a needed shared library */
#macro ELIBBAD         80      /* Accessing a corrupted shared library */
#macro ELIBSCN         81      /* .lib section in a.out corrupted */
#macro ELIBMAX         82      /* Attempting to link in too many shared libraries */
#macro ELIBEXEC        83      /* Cannot exec a shared library directly */
#macro EILSEQ          84      /* Illegal byte sequence */
#macro ERESTART        85      /* Interrupted system call should be restarted */
#macro ESTRPIPE        86      /* Streams pipe error */
#macro EUSERS          87      /* Too many users */
#macro ENOTSOCK        88      /* Socket operation on non-socket */
#macro EDESTADDRREQ    89      /* Destination address required */
#macro EMSGSIZE        90      /* Message too long */
#macro EPROTOTYPE      91      /* Protocol wrong type for socket */
#macro ENOPROTOOPT     92      /* Protocol not available */
#macro EPROTONOSUPPORT 93      /* Protocol not supported */
#macro ESOCKTNOSUPPORT 94      /* Socket type not supported */
#macro EOPNOTSUPP      95      /* Operation not supported on transport endpoint */
#macro EPFNOSUPPORT    96      /* Protocol family not supported */
#macro EAFNOSUPPORT    97      /* Address family not supported by protocol */
#macro EADDRINUSE      98      /* Address already in use */
#macro EADDRNOTAVAIL   99      /* Cannot assign requested address */
#macro ENETDOWN        100     /* Network is down */
#macro ENETUNREACH     101     /* Network is unreachable */
#macro ENETRESET       102     /* Network dropped connection because of reset */
#macro ECONNABORTED    103     /* Software caused connection abort */
#macro ECONNRESET      104     /* Connection reset by peer */
#macro ENOBUFS         105     /* No buffer space available */
#macro EISCONN         106     /* Transport endpoint is already connected */
#macro ENOTCONN        107     /* Transport endpoint is not connected */
#macro ESHUTDOWN       108     /* Cannot send after transport endpoint shutdown */
#macro ETOOMANYREFS    109     /* Too many references: cannot splice */
#macro ETIMEDOUT       110     /* Connection timed out */
#macro ECONNREFUSED    111     /* Connection refused */
#macro EHOSTDOWN       112     /* Host is down */
#macro EHOSTUNREACH    113     /* No route to host */
#macro EALREADY        114     /* Operation already in progress */
#macro EINPROGRESS     115     /* Operation now in progress */
#macro ESTALE          116     /* Stale file handle */
#macro EUCLEAN         117     /* Structure needs cleaning */
#macro ENOTNAM         118     /* Not a XENIX named type file */
#macro ENAVAIL         119     /* No XENIX semaphores available */
#macro EISNAM          120     /* Is a named type file */
#macro EREMOTEIO       121     /* Remote I/O error */
#macro EDQUOT          122     /* Quota exceeded */

#macro ENOMEDIUM       123     /* No medium found */
#macro EMEDIUMTYPE     124     /* Wrong medium type */
#macro ECANCELED       125     /* Operation Canceled */
#macro ENOKEY          126     /* Required key not available */
#macro EKEYEXPIRED     127     /* Key has expired */
#macro EKEYREVOKED     128     /* Key has been revoked */
#macro EKEYREJECTED    129     /* Key was rejected by service */


fn name_of_error(err: i64) -> char[] {
    err = -err;
    // TODO: Make a global table of strings.
    switch (err) {
        #macro SWITCH_CASES(X,Y,...) case X: return Y; SWITCH_CASES(...)
        SWITCH_CASES(
            EPERM,"EPERM",
            ENOENT, "ENOENT",
            ESRCH, "ESRCH",
            EINTR, "EINTR",
            EIO, "EIO",
            ENXIO, "ENXIO",
            E2BIG, "E2BIG",
            ENOEXEC, "ENOEXEC",
            EBADF, "EBADF",
            ECHILD, "ECHILD",
            EAGAIN, "EAGAIN",
            ENOMEM, "ENOMEM",
            EACCES, "EACCES",
            EFAULT, "EFAULT",
            ENOTBLK, "ENOTBLK",
            EBUSY, "EBUSY",
            EEXIST, "EEXIST",
            EXDEV, "EXDEV",
            ENODEV, "ENODEV",
            ENOTDIR, "ENOTDIR",
            EISDIR, "EISDIR",
            EINVAL, "EINVAL",
            ENFILE, "ENFILE",
            EMFILE, "EMFILE",
            ENOTTY, "ENOTTY",
            ETXTBSY, "ETXTBSY",
            EFBIG, "EFBIG",
            ENOSPC, "ENOSPC",
            ESPIPE, "ESPIPE",
            EROFS, "EROFS",
            EMLINK, "EMLINK",
            EPIPE, "EPIPE",
            EDOM, "EDOM",
            ERANGE, "ERANGE",
            ENOSYS, "ENOSYS",                    /* Invalid system call number */
            ENOTEMPTY, "ENOTEMPTY",              /* Directory not empty */
            ELOOP, "ELOOP",                      /* Too many symbolic links encountered */
            EWOULDBLOCK, "EWOULDBLOCK",          /* Operation would block */
            ENOMSG, "ENOMSG",                    /* No message of desired type */
            EIDRM, "EIDRM",                      /* Identifier removed */
            ECHRNG, "ECHRNG",                    /* Channel number out of range */
            EL2NSYNC, "EL2NSYNC",                /* Level 2 not synchronized */
            EL3HLT, "EL3HLT",                    /* Level 3 halted */
            EL3RST, "EL3RST",                    /* Level 3 reset */
            ELNRNG, "ELNRNG",                    /* Link number out of range */
            EUNATCH, "EUNATCH",                  /* Protocol driver not attached */
            ENOCSI, "ENOCSI",                    /* No CSI structure available */
            EL2HLT, "EL2HLT",                    /* Level 2 halted */
            EBADE, "EBADE",                      /* Invalid exchange */
            EBADR, "EBADR",                      /* Invalid request descriptor */
            EXFULL, "EXFULL",                    /* Exchange full */
            ENOANO, "ENOANO",                    /* No anode */
            EBADRQC, "EBADRQC",                  /* Invalid request code */
            EBADSLT, "EBADSLT",                  /* Invalid slot */
            // EDEADLOCK, "EDEADLOCK",              
            EBFONT, "EBFONT",                    /* Bad font file format */
            ENOSTR, "ENOSTR",                    /* Device not a stream */
            ENODATA, "ENODATA",                  /* No data available */
            ETIME, "ETIME",                      /* Timer expired */
            ENOSR, "ENOSR",                      /* Out of streams resources */
            ENONET, "ENONET",                    /* Machine is not on the network */
            ENOPKG, "ENOPKG",                    /* Package not installed */
            EREMOTE, "EREMOTE",                  /* Object is remote */
            ENOLINK, "ENOLINK",                  /* Link has been severed */
            EADV, "EADV",                        /* Advertise error */
            ESRMNT, "ESRMNT",                    /* Srmount error */
            ECOMM, "ECOMM",                      /* Communication error on send */
            EPROTO, "EPROTO",                    /* Protocol error */
            EMULTIHOP, "EMULTIHOP",              /* Multihop attempted */
            EDOTDOT, "EDOTDOT",                  /* RFS specific error */
            EBADMSG, "EBADMSG",                  /* Not a data message */
            EOVERFLOW, "EOVERFLOW",              /* Value too large for macrod data type */
            ENOTUNIQ, "ENOTUNIQ",                /* Name not unique on network */
            EBADFD, "EBADFD",                    /* File descriptor in bad state */
            EREMCHG, "EREMCHG",                  /* Remote address changed */
            ELIBACC, "ELIBACC",                  /* Can not access a needed shared library */
            ELIBBAD, "ELIBBAD",                  /* Accessing a corrupted shared library */
            ELIBSCN, "ELIBSCN",                  /* .lib section in a.out corrupted */
            ELIBMAX, "ELIBMAX",                  /* Attempting to link in too many shared libraries */
            ELIBEXEC, "ELIBEXEC",                /* Cannot exec a shared library directly */
            EILSEQ, "EILSEQ",                    /* Illegal byte sequence */
            ERESTART, "ERESTART",                /* Interrupted system call should be restarted */
            ESTRPIPE, "ESTRPIPE",                /* Streams pipe error */
            EUSERS, "EUSERS",                    /* Too many users */
            ENOTSOCK, "ENOTSOCK",                /* Socket operation on non-socket */
            EDESTADDRREQ, "EDESTADDRREQ",        /* Destination address required */
            EMSGSIZE, "EMSGSIZE",                /* Message too long */
            EPROTOTYPE, "EPROTOTYPE",            /* Protocol wrong type for socket */
            ENOPROTOOPT, "ENOPROTOOPT",          /* Protocol not available */
            EPROTONOSUPPORT, "EPROTONOSUPPORT",  /* Protocol not supported */
            ESOCKTNOSUPPORT, "ESOCKTNOSUPPORT",  /* Socket type not supported */
            EOPNOTSUPP, "EOPNOTSUPP",            /* Operation not supported on transport endpoint */
            EPFNOSUPPORT, "EPFNOSUPPORT",        /* Protocol family not supported */
            EAFNOSUPPORT, "EAFNOSUPPORT",        /* Address family not supported by protocol */
            EADDRINUSE, "EADDRINUSE",            /* Address already in use */
            EADDRNOTAVAIL, "EADDRNOTAVAIL",      /* Cannot assign requested address */
            ENETDOWN, "ENETDOWN",                /* Network is down */
            ENETUNREACH, "ENETUNREACH",          /* Network is unreachable */
            ENETRESET, "ENETRESET",              /* Network dropped connection because of reset */
            ECONNABORTED, "ECONNABORTED",        /* Software caused connection abort */
            ECONNRESET, "ECONNRESET",            /* Connection reset by peer */
            ENOBUFS, "ENOBUFS",                  /* No buffer space available */
            EISCONN, "EISCONN",                  /* Transport endpoint is already connected */
            ENOTCONN, "ENOTCONN",                /* Transport endpoint is not connected */
            ESHUTDOWN, "ESHUTDOWN",              /* Cannot send after transport endpoint shutdown */
            ETOOMANYREFS, "ETOOMANYREFS",        /* Too many references: cannot splice */
            ETIMEDOUT, "ETIMEDOUT",              /* Connection timed out */
            ECONNREFUSED, "ECONNREFUSED",        /* Connection refused */
            EHOSTDOWN, "EHOSTDOWN",              /* Host is down */
            EHOSTUNREACH, "EHOSTUNREACH",        /* No route to host */
            EALREADY, "EALREADY",                /* Operation already in progress */
            EINPROGRESS, "EINPROGRESS",          /* Operation now in progress */
            ESTALE, "ESTALE",                    /* Stale file handle */
            EUCLEAN, "EUCLEAN",                  /* Structure needs cleaning */
            ENOTNAM, "ENOTNAM",                  /* Not a XENIX named type file */
            ENAVAIL, "ENAVAIL",                  /* No XENIX semaphores available */
            EISNAM, "EISNAM",                    /* Is a named type file */
            EREMOTEIO, "EREMOTEIO",              /* Remote I/O error */
            EDQUOT, "EDQUOT",                    /* Quota exceeded */
            ENOMEDIUM, "ENOMEDIUM",              /* No medium found */
            EMEDIUMTYPE, "EMEDIUMTYPE",          /* Wrong medium type */
            ECANCELED, "ECANCELED",              /* Operation Canceled */
            ENOKEY, "ENOKEY",                    /* Required key not available */
            EKEYEXPIRED, "EKEYEXPIRED",          /* Key has expired */
            EKEYREVOKED, "EKEYREVOKED",          /* Key has been revoked */
            EKEYREJECTED, "EKEYREJECTED",        /* Key was rejected by service */

            
        )
    }
    return "<unnamed>"
}

